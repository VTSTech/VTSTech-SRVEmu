// ============================================================================
// HASH TABLE SYSTEM - Complete Reference
// Functions: 0x0031ffe0 - 0x003203e8
// Based on Ghidra Analysis - ALL ALGORITHMS VERIFIED
// ============================================================================

==================================================
                   OVERVIEW
==================================================
Custom hash table implementation for storing rooms, users, and rankings.
Uses multiplicative hash algorithm with chaining for collision resolution.
Memory managed through buddy allocator pools for efficiency.

==================================================
            DATA STRUCTURES
==================================================
struct HashTable {                 // Approximately 20+ bytes
    int num_buckets;               // +0x00: Number of buckets
    int entry_count;               // +0x04: Total entries
    void** buckets;                // +0x08: Array of bucket pointers
    int unknown1;                  // +0x0C: Unknown (padding?)
    int unknown2;                  // +0x10: Unknown (padding?)
    int table_size;                // +0x14: Size for modulo operation
    // Additional fields may exist
};

struct HashEntry {                 // Variable size depending on data type
    int key;                       // +0x00: Numeric key (room/user ID)
    void* value;                   // +0x04: Pointer to data
    HashEntry* next;               // +0x08: Next entry in chain (for collisions)
};

// Data structures stored in hash tables:
struct RoomEntry {                 // 104 bytes (0x68)
    int id;                        // +0x00: Room ID
    int flags;                     // +0x04: Room flags
    int max_players;               // +0x08: Maximum players
    int current_players;           // +0x0C: Current players
    char display_ip[16];           // +0x10: Display IP string
    char status[16];               // +0x20: Status string
    char password[8];              // +0x30: Password display
    int host_ip;                   // +0x38: Host IP address
    char name[32];                 // +0x3C: Room name
    char description[32];          // +0x5C: Room description
};

struct UserEntry {                 // 312 bytes (0x138)
    int id;                        // +0x00: User ID
    int flags;                     // +0x04: User flags
    char username[32];             // +0x08: Username
    char password[8];              // +0x28: Password hash
    int rank;                      // +0x30: User rank
    int host_ip;                   // +0x34: Host IP address
    char description[128];         // +0x38: User description
    char extra_info[128];          // +0xB8: Extra information
};

==================================================
            HASH ALGORITHM
==================================================
// HashTable_ComputeHash (0x0031ffe0)
/**
 * Multiplicative hash algorithm for string keys.
 * 
 * Algorithm: hash = ((hash * 0x83) + (ch & 0x5f)) & 0x7fffffff
 * Where: 0x83 = 131 (prime), 0x5f converts lowercase to uppercase
 * 
 * @param table    HashTable structure pointer
 * @param key      Null-terminated string key
 * @return Bucket index (hash % table->table_size)
 * 
 * Key Characteristics:
 * - Skips control characters (ch <= ' ')
 * - Converts to uppercase via (ch & 0x5f)
 * - Uses prime 131 for multiplication
 * - Masks to 31 bits (0x7fffffff) before modulo
 */
int HashTable_ComputeHash(HashTable* table, const char* key) {
    uint32_t hash = 0;
    char ch = *key;
    
    // Handle empty string case
    if (ch == 0) {
        return table->table_size;  // Returns size, not index
    }
    
    // Process each character
    while (ch != 0) {
        if (ch > ' ') {  // Skip control characters (space and below)
            // Convert to uppercase and accumulate
            hash = hash * 0x83 + (ch & 0x5f);
        }
        key++;
        ch = *key;
    }
    
    // Ensure table size is valid
    if (table->table_size == 0) {
        trap(7);  // Division by zero trap
    }
    
    // Return bucket index
    return (int)(hash & 0x7fffffff) % table->table_size;
}

// Python equivalent for emulator:
def compute_string_hash(key: str, table_size: int) -> int:
    hash_val = 0
    for ch in key:
        if ord(ch) > 32:  # Skip control characters
            # Convert to uppercase (ASCII a-z â†’ A-Z)
            upper_ch = ord(ch) & 0x5f  # Same as: ch.upper() but faster
            hash_val = (hash_val * 0x83 + upper_ch) & 0x7fffffff
    return hash_val % table_size

// For numeric keys (room/user IDs):
// Typically uses direct modulo: key % table_size

==================================================
            CORE OPERATIONS
==================================================

// ================================================
// HashTable_Create (0x0031fd98)
// ================================================
/**
 * Initializes a new hash table.
 * 
 * @param num_buckets  Number of buckets to create
 * @return Pointer to new HashTable, or NULL on failure
 * 
 * Implementation:
 * - Allocates HashTable structure
 * - Allocates bucket array (num_buckets * sizeof(void*))
 * - Initializes all buckets to NULL
 * - Sets table_size = num_buckets
 */
HashTable* HashTable_Create(int num_buckets);

// ================================================
// HashTable_Insert (0x003202b8)
// ================================================
/**
 * Inserts key-value pair into hash table.
 * 
 * @param table  HashTable pointer
 * @param key    Integer key (room/user ID)
 * @param value  Pointer to data (RoomEntry/UserEntry)
 * @return 1 on success, 0 on failure
 * 
 * Implementation:
 * - Computes bucket index: key % table->table_size
 * - Creates new HashEntry
 * - Adds to front of chain (for collisions)
 * - Updates entry_count
 */
int HashTable_Insert(HashTable* table, int key, void* value);

// ================================================
// HashTable_Lookup (0x00320390)
// ================================================
/**
 * Looks up value by key.
 * 
 * @param table  HashTable pointer
 * @param key    Integer key to find
 * @return Pointer to value, or NULL if not found
 * 
 * Implementation:
 * - Computes bucket index: key % table->table_size
 * - Traverses chain at that bucket
 * - Compares keys until match found
 */
void* HashTable_Lookup(HashTable* table, int key);

// ================================================
// HashTable_Remove (0x003203e8)
// ================================================
/**
 * Removes key-value pair from hash table.
 * 
 * @param table  HashTable pointer
 * @param key    Integer key to remove
 * @return Pointer to removed value, or NULL if not found
 * 
 * Implementation:
 * - Finds entry in chain
 * - Removes from linked list
 * - Updates entry_count
 * - Returns value pointer (caller must free)
 */
void* HashTable_Remove(HashTable* table, int key);

// ================================================
// HashTable_Resize (0x0031fea0)
// ================================================
/**
 * Resizes hash table to new number of buckets.
 * 
 * @param table        HashTable pointer
 * @param new_size     New number of buckets
 * @return 1 on success, 0 on failure
 * 
 * Implementation:
 * - Allocates new bucket array
 * - Rehashes all existing entries
 * - Frees old bucket array
 */
int HashTable_Resize(HashTable* table, int new_size);

==================================================
            BUDDY ALLOCATOR INTEGRATION
==================================================
// The hash table system uses buddy allocator pools for data storage
// Each hash table has associated data pool for entries

// Buddy_CreateUserEntry (not directly in hash code)
// Allocates fixed-size entries from pool
// Returns handle for hash table storage

// Buddy_UpdateUserData
// Updates existing entry without reallocation
// Uses memcpy with alignment handling

// Buddy_FreeUserData
// Returns entry to pool for reuse

==================================================
            STRING-BASED OPERATIONS
==================================================
// These functions use the ComputeStringHash algorithm

// ================================================
// Buddy_FindUserByString (called from 0x003201a0)
// ================================================
/**
 * Finds user entry by username string.
 * 
 * @param table    HashTable pointer (user table)
 * @param username String key to find
 * @return HashEntry pointer, or NULL if not found
 * 
 * Implementation:
 * - Uses HashTable_ComputeHash for bucket index
 * - Traverses chain comparing usernames
 * - Uses case-insensitive comparison
 */
HashEntry* Buddy_FindUserByString(HashTable* table, const char* username);

// ================================================
// Buddy_AddUser (0x003200e0)
// ================================================
/**
 * Adds user entry with string key.
 * 
 * @param table    HashTable pointer
 * @param username String key
 * @param value    Pointer to user data
 * @return 1 on success, 0 on failure
 */
int Buddy_AddUser(HashTable* table, const char* username, void* value);

// ================================================
// Buddy_RemoveUser (0x00320220)
// ================================================
/**
 * Removes user entry by string key.
 * 
 * @param table    HashTable pointer
 * @param username String key to remove
 * @return HashEntry pointer (caller must free)
 */
HashEntry* Buddy_RemoveUser(HashTable* table, const char* username);

==================================================
            MEMORY MANAGEMENT
==================================================

// ================================================
// HashTable_AllocateEntry (0x0031f948)
// ================================================
/**
 * Allocates new hash table entry from pool.
 * 
 * @param pool   Buddy allocator pool pointer
 * @param data   Pointer to data to store
 * @return Handle/index for hash table storage
 */
int HashTable_AllocateEntry(void* pool, void* data);

// ================================================
// HashTable_UpdateEntry (0x0031fa00)
// ================================================
/**
 * Updates existing entry with new data.
 * 
 * @param pool   Buddy allocator pool pointer
 * @param entry  HashEntry pointer to update
 * @param data   New data pointer
 * @return 1 on success, 0 on failure
 */
int HashTable_UpdateEntry(void* pool, HashEntry* entry, void* data);

// ================================================
// HashTable_FreeEntry (0x0031faa0)
// ================================================
/**
 * Frees hash table entry back to pool.
 * 
 * @param pool   Buddy allocator pool pointer
 * @param entry  HashEntry pointer to free
 * @return Handle that was freed
 */
int HashTable_FreeEntry(void* pool, HashEntry* entry);

==================================================
            ITERATION FUNCTIONS
==================================================

// ================================================
// Buddy_GetNextUser (0x0031ff50)
// ================================================
/**
 * Iterates through all users in hash table.
 * 
 * @param table    HashTable pointer
 * @return Next HashEntry pointer, or NULL when done
 * 
 * Usage pattern:
 * while ((entry = Buddy_GetNextUser(table)) != NULL) {
 *     // Process entry
 * }
 * 
 * Implementation:
 * - Maintains iteration state in table or global
 * - Walks through all buckets and chains
 */
HashEntry* Buddy_GetNextUser(HashTable* table);

// ================================================
// Buddy_GetUserData (0x0031fa88)
// ================================================
/**
 * Retrieves data pointer from entry handle.
 * 
 * @param pool   Buddy allocator pool pointer
 * @param handle Entry handle/index
 * @return Pointer to user data (RoomEntry/UserEntry)
 */
void* Buddy_GetUserData(void* pool, int handle);

==================================================
            PERFORMANCE CHARACTERISTICS
==================================================
Table Sizes:
- Room table: Typically 128 buckets
- User table: Typically 256 buckets
- Rank table: Varies based on ranking type

Load Factor:
- Target: < 0.75 (average chain length < 3)
- Automatic resize when threshold exceeded

Memory Usage:
- RoomEntry: 104 bytes each
- UserEntry: 312 bytes each
- HashEntry overhead: ~12 bytes per entry
- Bucket array: num_buckets * 4 bytes

Collision Resolution:
- Separate chaining with linked lists
- New entries added to front of chain
- O(1) average case, O(n) worst case

==================================================
            USAGE IN LOBBY SYSTEM
==================================================

// Room Table (LobbyContext +0xC4)
HashTable* room_table = ctx->room_table;
RoomEntry* room = HashTable_Lookup(room_table, room_id);

// User Table (LobbyContext +0xC9)
HashTable* user_table = ctx->user_table;
UserEntry* user = HashTable_Lookup(user_table, user_id);

// Rank Table (LobbyContext +0xCE)
HashTable* rank_table = ctx->rank_table;
RankEntry* rank = HashTable_Lookup(rank_table, rank_id);

==================================================
            DEBUGGING TIPS
==================================================
Common Issues:
1. Hash collision storms (poor key distribution)
2. Memory leaks (entries not freed)
3. Invalid pool handles
4. Concurrent modification during iteration

Debug Functions:
- HashTable_ComputeHash: Verify hash values
- Buddy_GetNextUser: Check iteration state
- Check table_size != 0 before modulo

==================================================
            EMULATOR IMPLEMENTATION
==================================================
Python implementation example:

class HashTable:
    def __init__(self, num_buckets=128):
        self.num_buckets = num_buckets
        self.table_size = num_buckets  # For modulo operation
        self.buckets = [[] for _ in range(num_buckets)]
        self.entry_count = 0
        
    def compute_hash(self, key):
        """String hash algorithm matching ComputeStringHash"""
        if isinstance(key, str):
            hash_val = 0
            for ch in key:
                if ord(ch) > 32:
                    upper_ch = ord(ch) & 0x5f
                    hash_val = (hash_val * 0x83 + upper_ch) & 0x7fffffff
            return hash_val % self.table_size
        else:
            # Numeric key
            return key % self.table_size
            
    def insert(self, key, value):
        bucket_idx = self.compute_hash(key)
        # Check for existing key
        for i, (k, v) in enumerate(self.buckets[bucket_idx]):
            if k == key:
                self.buckets[bucket_idx][i] = (key, value)
                return
        # Add new entry
        self.buckets[bucket_idx].append((key, value))
        self.entry_count += 1
        
    def lookup(self, key):
        bucket_idx = self.compute_hash(key)
        for k, v in self.buckets[bucket_idx]:
            if k == key:
                return v
        return None
        
    def remove(self, key):
        bucket_idx = self.compute_hash(key)
        for i, (k, v) in enumerate(self.buckets[bucket_idx]):
            if k == key:
                self.buckets[bucket_idx].pop(i)
                self.entry_count -= 1
                return v
        return None